module.exports = function (dirName, callback) {
    var fs = require('fs'), path = require('path'), AdmZip = require('adm-zip'),

        booksPath = dirName + '/books/',
        cachePath = booksPath + 'cache/',
        booksPathDoesntExist = !fs.existsSync(booksPath),
        cacheDoesntExist = !fs.existsSync(cachePath);

    if (booksPathDoesntExist) {
        fs.mkdirSync(booksPath);
    }

    if (cacheDoesntExist) {
        fs.mkdirSync(cachePath);
    }

    function asyncUnzipBooks(bookFile, extractPath) {
        var bookName = path.basename(bookFile, '.etb');
        if (bookName.split('-')[0] == 'downloading')
            fs.unlink(booksPath + bookFile);
        else {
            var location = cachePath + bookName;
            var zip = new AdmZip(extractPath + bookFile);

            try {
                zip.extractAllTo(location, true);
                //TODO doesn't catch exception. Had to edit ADM-Zip sources to fix.
            } catch (e) {
                console.log('Caught exception: ', e);
            }
        }
    }

    function extractNewBooks(booksPath, callback) {
        fs.readdir(booksPath, function (err, books) {
            if (err && typeof callback == "function") callback(err);
            else {
                books
                    .filter(function (book) {
                        return path.extname(book) === ".etb";
                    })
                    .filter(function (book) {
                        return !fs.existsSync(cachePath + path.basename(book, '.etb'));
                    })
                    .forEach(function (book) {
                        asyncUnzipBooks(book, booksPath);
                    });
                if (typeof callback == "function") callback(null);
            }
        })
    }


    function getBookDirectoriesList(cachePath, callback) {
        fs.readdir(cachePath, function (err, files) {
            var directories = [];
            files
                .map(function (file) {
                    return path.join(cachePath, file);
                })
                .filter(function (file) {
                    return fs.statSync(file).isDirectory();
                })
                .filter(function (file) {
                    return fs.existsSync(file + '/book.info');
                })
                .forEach(function (file) {
                    directories.push(file);
                });
            if (typeof callback == "function") callback(null, directories);
        });
    }

    extractNewBooks(booksPath, function (err) {
        if (!err)
            getBookDirectoriesList(cachePath, function (err, cb) {
                if (!err)
                    if (typeof callback == "function") callback(null, cb);
                    else if (typeof callback == "function") callback(err, null);
            });

        else if (typeof callback == "function") callback(err, null);
    });
};
